# 机器学习面试150题

<ol><li>请详细说说支持向量机（support vector machine，SVM）的原理<br> &nbsp; &nbsp; 支持向量机，因其英文名为support vector machine，故一般简称SVM，通俗来讲，它是一种二类分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，其学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。</li><li>哪些机器学习算法不需要做归一化处理？ <p>在实际应用中，需要归一化的模型：<br> 1.基于距离计算的模型：KNN。<br> 2.通过梯度下降法求解的模型：线性回归、逻辑回归、支持向量机、神经网络。</p> <p>但树形模型不需要归一化，因为它们不关心变量的值，而是关心变量的分布和变量之间的条件概率，如决策树、随机森林(Random Forest)。</p> </li><li>树形结构为什么不需要归一化？<br> 因为数值缩放不影响分裂点位置，对树模型的结构不造成影响。<br> 按照特征值进行排序的，排序的顺序不变，那么所属的分支以及分裂点就不会有不同。而且，树模型是不能进行梯度下降的，因为构建树模型（回归树）寻找最优点时是通过寻找最优分裂点完成的，因此树模型是阶跃的，阶跃点是不可导的，并且求导没意义，也就不需要归一化。</li><li>在k-means或kNN，我们常用欧氏距离来计算最近的邻居之间的距离，有时也用曼哈顿距离，请对比下这两种距离的差别<br> 欧氏距离，最常见的两点之间或多点之间的距离表示法，又称之为欧几里得度量，它定义于欧几里得空间中..</li><li>数据归一化（或者标准化，注意归一化和标准化不同）的原因 <p>能不归一化最好不归一化，之所以进行数据归一化是因为各维度的量纲不相同。而且需要看情况进行归一化。</p> <p>&nbsp; &nbsp; 有些模型在各维度进行了不均匀的伸缩后，最优解与原来不等价（如SVM）需要归一化。<br> &nbsp; &nbsp; 有些模型伸缩有与原来等价，如：LR则不用归一化，但是实际中往往通过迭代求解模型参数，如果目标函数太扁（想象一下很扁的高斯模型）迭代算法会发生不收敛的情况，所以最好进行数据归一化。</p> </li><li>请简要说说一个完整机器学习项目的流程 <p>1 抽象成数学问题<br> 明确问题是进行机器学习的第一步。机器学习的训练过程通常都是一件非常耗时的事情，胡乱尝试时间成本是非常高的。<br> 这里的抽象成数学问题，指的我们明确我们可以获得什么样的数据，目标是一个分类还是回归或者是聚类的问题，如果都不是的话，如果划归为其中的某类问题。</p> <p>2 获取数据<br> 数据决定了机器学习结果的上限，而算法只是尽可能逼近这个上限。<br> 数据要有代表性，否则必然会过拟合。<br> 而且对于分类问题，数据偏斜不能过于严重，不同类别的数据数量不要有数个数量级的差距。<br> 而且还要对数据的量级有一个评估，多少个样本，多少个特征，可以估算出其对内存的消耗程度，判断训练过程中内存是否能够放得下。如果放不下就得考虑改进算法或者使用一些降维的技巧了。如果数据量实在太大，那就要考虑分布式了。</p> <p>3 特征预处理与特征选择<br> 良好的数据要能够提取出良好的特征..</p> </li><li>逻辑斯蒂回归为什么要对特征进行离散化 <p>如七月在线老师所说<br> ① 非线性！非线性！非线性！逻辑回归属于广义线性模型，表达能力受限；单变量离散化为N个后，每个变量有单独的权重，相当于为模型引入了非线性，能够提升模型表达能力，加大拟合； 离散特征的增加和减少都很容易，易于模型的快速迭代；&nbsp;</p> <p>② 速度快！速度快！速度快！稀疏向量内积乘法运算速度快，计算结果方便存储，容易扩展；&nbsp;</p> <p>③ 鲁棒性！鲁棒性！鲁棒性！离散化后的特征对异常数据有很强的鲁棒性：比如一个特征是年龄&gt;30是1，否则0。如果特征没有离散化，一个异常数据“年龄300岁”会给模型造成很大的干扰；&nbsp;</p> <p>④ 方便交叉与特征组合：离散化后可以进行特征交叉，由M+N个变量变为M*N个变量，进一步引入非线性，提升表达能力；&nbsp;</p> <p>⑤ 稳定性：特征离散化后，模型会更稳定，比如如果对用户年龄离散化，20-30作为一个区间，不会因为一个用户年龄长了一岁就变成一个完全不同的人。当然处于区间相邻处的样本会刚好相反，所以怎么划分区间是门学问；&nbsp;</p> <p>⑥ 简化模..</p> </li><li>简单介绍下LR <p>@rickjin：把LR从头到脚都给讲一遍。建模，现场数学推导，每种解法的原理，正则化，LR和maxent模型啥关系。有不少会背答案的人，问逻辑细节就糊涂了。</p> <p>原理都会? 那就问工程，并行化怎么做，有几种并行化方式，读过哪些开源的实现。还会，那就准备收了吧，顺便逼问LR模型发展历史。</p> <p>虽然逻辑斯蒂回归姓回归，不过其实它的真实身份是二分类器。先弄清楚一个概念：线性分类器..</p> </li><li>overfitting怎么解决<br> overfitting就是过拟合, 其直观的表现如下图所示，随着训练过程的进行，模型复杂度增加，在training data上的error渐渐减小，但是在验证集上的error却反而渐渐增大——因为训练出来的网络过拟合了训练集, 对训练集外的数据却不work, 这称之为泛化(generalization)性能不好。泛化性能是训练的效果评价中的首要目标，没有良好的泛化，就等于南辕北辙, 一切都是无用功。</li><li>LR和SVM的联系与区别 <p>解析一<br> LR和SVM都可以处理分类问题，且一般都用于处理线性二分类问题（在改进的情况下可以处理多分类问题）&nbsp;</p> <p>区别：&nbsp;<br> 1、LR是参数模型，svm是非参数模型，linear和rbf则是针对数据线性可分和不可分的区别；<br> 2、从目标函数来看，区别在于逻辑回归采用的是logistical loss，SVM采用的是hinge loss，这两个损失函数的目的都是增加对分类影响较大的数据点的权重，减少与分类关系较小的数据点的权重。&nbsp;</p> <p>3..</p> </li><li>什么是熵<br> &nbsp;从名字上来看，熵给人一种很玄乎，不知道是啥的感觉。其实，熵的定义很简单，即用来表示随机变量的不确定性。之所以给人玄乎的感觉，大概是因为为何要取这样的名字，以及怎么用。<br> &nbsp; &nbsp; 熵的概念最早起源于物理学，用于度量一个热力学系统的无序程度。在信息论里面，熵是对不确定性的测量。</li><li>说说梯度下降法 <p>1 什么是梯度下降法<br> 经常在机器学习中的优化问题中看到一个算法，即梯度下降法，那到底什么是梯度下降法呢？</p> <p>维基百科给出的定义是梯度下降法（Gradient descent）是一个一阶最优化算法，通常也称为最速下降法。 要使用梯度下降法找到一个函数的局部极小值，必须向函数上当前点对应梯度（或者是近似梯度）的反方向的规定步长距离点进行迭代搜索。如果相反地向梯度正方向迭代进行搜索，则会接近函数的局部极大值点；这个过程则被称为梯度上升法。..</p> </li><li>牛顿法和梯度下降法有什么不同？<br> 牛顿法（Newton's method）<br> 牛顿法是一种在实数域和复数域上近似求解方程的方法。方法使用函数f (x)的泰勒级数的前面几项来寻找方程f (x) = 0的根。牛顿法最大的特点就在于它的收敛速度很快。..</li><li>熵、联合熵、条件熵、相对熵、互信息的定义<br> 为了更好的理解，需要了解的概率必备知识有：<br> 大写字母X表示随机变量，小写字母x表示随机变量X的某个具体的取值；<br> P(X)表示随机变量X的概率分布，P(X,Y)表示随机变量X、Y的联合概率分布，P(Y|X)表示已知随机变量X的情况下随机变量Y的条件概率分布；<br> p(X = x)表示随机变量X取某个具体值的概率，简记为p(x)；<br> p(X = x, Y = y) 表示联合概率，简记为p(x,y)，p(Y = y|X = x)表示条件概率，简记为p(y|x)，且有：p(x,y) = p(x) * p(y|x)。</li><li>说说你知道的核函数<br> 通常人们会从一些常用的核函数中选择（根据问题和数据的不同，选择不同的参数，实际上就是得到了不同的核函数），例如：</li><li>什么是拟牛顿法（Quasi-Newton Methods）？ <p>拟牛顿法是求解非线性优化问题最有效的方法之一，于20世纪50年代由美国Argonne国家实验室的物理学家W.C.Davidon所提出来。Davidon设计的这种算法在当时看来是非线性优化领域最具创造性的发明之一。不久R. Fletcher和M. J. D. Powell证实了这种新的算法远比其他方法快速和可靠，使得非线性优化这门学科在一夜之间突飞猛进。</p> <p>拟牛顿法的本质思想是改善牛顿法每次需要求解复杂的Hessian矩阵的逆矩阵的缺陷，它使用正定矩阵来近似Hessian矩阵的逆，从而简化了运算的复杂度。拟牛顿法和最速下降法一样只要求每一步迭代时知道目标函数的梯度。通过测量梯度的变化，构造一个目标函数的模型使之足以产生超线性收敛性。这类方法大大优于最速下降法，尤其对于困难的问题。..</p> </li><li>kmeans的复杂度？<br> 时间复杂度：O(tKmn)，其中，t为迭代次数，K为簇的数目，m为记录数（也可认为是样本数），n为维数<br> 空间复杂度：O((m+K)n)，其中，K为簇的数目，m为记录数（也可认为是样本数），n为维数..</li><li>请说说随机梯度下降法的问题和挑战？<br> 那到底如何优化随机梯度法呢？详情请点击：论文公开课第一期：详解梯度下降等各类优化算法（含视频和PPT下载）（链接：https://ask.julyedu.com/question/7913）</li><li>说说共轭梯度法？<br> &nbsp;共轭梯度法是介于梯度下降法（最速下降法）与牛顿法之间的一个方法，它仅需利用一阶导数信息，但克服了梯度下降法收敛慢的缺点，又避免了牛顿法需要存储和计算Hessian矩阵并求逆的缺点，共轭梯度法不仅是解决大型线性方程组最有用的方法之一，也是解大型非线性最优化最有效的算法之一。在各种优化算法中，共轭梯度法是非常重要的一种。其优点是所需存储量小，具有逐步收敛性，稳定性高，而且不需要任何外来参数。</li><li>对所有优化问题来说, 有没有可能找到比現在已知算法更好的算法？ <p>没有免费的午餐定理：<br> 对于训练样本（黑点），不同的算法A/B在不同的测试样本（白点）中有不同的表现，这表示：对于一个学习算法A，若它在某些问题上比学习算法 B更好，则必然存在一些问题，在那里B比A好。<br> 也就是说：对于所有问题，无论学习算法A多聪明，学习算法 B多笨拙，它们的期望性能相同。</p> <p>但是：没有免费午餐定理假设所有问题出现几率相同，实际应用中，不同的场景，会有不同的问题分布，所以，在优化算法时，针对具体问题进行分析，是算法优化的核心所在。</p> </li><li>什么是最大熵 <p>熵是随机变量不确定性的度量，不确定性越大，熵值越大；若随机变量退化成定值，熵为0。如果没有外界干扰，随机变量总是趋向于无序，在经过足够时间的稳定演化，它应该能够达到的最大程度的熵。 &nbsp;</p> <p>&nbsp; &nbsp; 为了准确的估计随机变量的状态，我们一般习惯性最大化熵，认为在所有可能的概率模型（分布）的集合中，熵最大的模型是最好的模型。换言之，在已知部分知识的前提下，关于未知分布最合理的推断就是符合已知知识最不确定或最随机的推断，其原则是承认已知事物（知识），且对未知事物不做任何假设，没有任何偏见..</p> </li><li>LR与线性回归的区别与联系<br> LR工业上一般指Logistic Regression(逻辑回归)而不是Linear Regression(线性回归). LR在线性回归的实数范围输出值上施加sigmoid函数将值收敛到0~1范围, 其目标函数也因此从差平方和函数变为对数损失函数, 以提供最优化所需导数（sigmoid函数是softmax函数的二元特例, 其导数均为函数值的f*(1-f)形式）。请注意, LR往往是解决二元0/1分类问题的, 只是它和线性回归耦合太紧, 不自觉也冠了个回归的名字(马甲无处不在). 若要求多元分类,就要把sigmoid换成大名鼎鼎的softmax了。</li><li>简单说下有监督学习和无监督学习的区别<br> 有监督学习：对具有标记的训练样本进行学习，以尽可能对训练样本集外的数据进行分类预测。（LR,SVM,BP,RF,GBDT）<br> 无监督学习：对未标记的样本进行训练学习，比发现这些样本中的结构知识。(KMeans,PCA)..</li><li>请问（决策树、Random Forest、Boosting、Adaboot）GBDT和XGBoost的区别是什么？ <p>集成学习的集成对象是学习器. Bagging和Boosting属于集成学习的两类方法. Bagging方法有放回地采样同数量样本训练每个学习器, 然后再一起集成(简单投票); Boosting方法使用全部样本(可调权重)依次训练每个学习器, 迭代集成(平滑加权).</p> <p>决策树属于最常用的学习器, 其学习过程是从根建立树, 也就是如何决策叶子节点分裂. ID3/C4.5决策树用信息熵计算最优分裂, CART决策树用基尼指数计算最优分裂, xgboost决策树使用二阶泰勒展开系数计算最优分裂..</p> </li><li>机器学习中的正则化到底是什么意思？ <p>其中，误差/损失函数鼓励我们的模型尽量去拟合训练数据，使得最后的模型会有比较少的 bias。而正则化项则鼓励更加简单的模型。因为当模型简单之后，有限数据拟合出来结果的随机性比较小，不容易过拟合，使得最后模型的预测更加稳定。</p> <p>但一直没有一篇好的文章理清到底什么是正则化？</p> <p>说到正则化，得先从过拟合问题开始谈起..</p> </li><li>说说常见的损失函数？<br> 对于给定的输入X，由f(X)给出相应的输出Y，这个输出的预测值f(X)与真实值Y可能一致也可能不一致（要知道，有时损失或误差是不可避免的），用一个损失函数来度量预测错误的程度。损失函数记为L(Y, f(X))，用来估量你模型的预测值f(x)与真实值Y的不一致程度..</li><li>为什么xgboost要用泰勒展开，优势在哪里？<br> xgboost使用了一阶和二阶偏导, 二阶导数有利于梯度下降的更快更准. 使用泰勒展开取得函数做自变量的二阶导数形式, 可以在不选定损失函数具体形式的情况下, 仅仅依靠输入数据的值就可以进行叶子分裂优化计算, 本质上也就把损失函数的选取和模型算法优化/参数选择分开了. 这种去耦合增加了xgboost的适用性, 使得它按需选取损失函数, 可以用于分类, 也可以用于回归..</li><li>协方差和相关性有什么区别？<br> 相关性是协方差的标准化格式。协方差本身很难做比较。例如：如果我们计算工资（$）和年龄（岁）的协方差，因为这两个变量有不同的度量，所以我们会得到不能做比较的不同的协方差。</li><li>xgboost如何寻找最优特征？是有放回还是无放回的呢？ <p>xgboost在训练的过程中给出各个特征的增益评分，最大增益的特征会被选出来作为分裂依据, 从而记忆了每个特征对在模型训练时的重要性 -- 从根到叶子中间节点涉及某特征的次数作为该特征重要性排序.</p> </li><li>谈谈判别式模型和生成式模型？<br> 判别方法：由数据直接学习决策函数 Y = f（X），或者由条件分布概率 P（Y|X）作为预测模型，即判别模型。<br> 生成方法：由数据学习联合概率密度分布函数 P（X,Y）,然后求出条件概率分布P(Y|X)作为预测的模型，即生成模型。<br> 由生成模型可以得到判别模型，但由判别模型得不到生成模型。<br> 常见的判别模型有：K近邻、SVM、决策树、感知机、线性判别分析（LDA）、线性回归、传统的神经网络、逻辑斯蒂回归、boosting、条件随机场<br> 常见的生成模型有：朴素贝叶斯、隐马尔可夫模型、高斯混合模型、文档主题生成模型（LDA）、限制玻尔兹曼机</li><li>线性分类器与非线性分类器的区别以及优劣<br> 线性和非线性是针对，模型参数和输入特征来讲的；比如输入x，模型y=ax+ax^2那么就是非线性模型，如果输入是x和X^2则模型是线性的。<br> 线性分类器可解释性好，计算复杂度较低，不足之处是模型的拟合效果相对弱些。<br> 非线性分类器效果拟合能力较强，不足之处是数据量不足容易过拟合、计算复杂度高、可解释性不好。<br> 常见的线性分类器有：LR,贝叶斯分类，单层感知机、线性回归<br> 常见的非线性分类器：决策树、RF、GBDT、多层感知机<br> SVM两种都有（看线性核还是高斯核）..</li><li>L1和L2的区别 <p>L1范数（L1 norm）是指向量中各个元素绝对值之和，也有个美称叫“稀疏规则算子”（Lasso regularization）。&nbsp;<br> 比如 向量A=[1，-1，3]， 那么A的L1范数为 |1|+|-1|+|3|.</p> <p>简单总结一下就是：&nbsp;<br> L1范数: 为x向量各个元素绝对值之和。&nbsp;<br> L2范数: 为x向量各个元素平方和的1/2次方，L2范数又称Euclidean范数或者Frobenius范数&nbsp;<br> Lp范数: 为x向量各个元素绝对值p次方和的1/p次方..</p> </li><li>L1和L2正则先验分别服从什么分布<br> 面试中遇到的，L1和L2正则先验分别服从什么分布，L1是拉普拉斯分布，L2是高斯分布。</li><li>简单介绍下logistics回归？ <p>逻辑回归（Logistic Regression）是机器学习中的一种分类模型，由于算法的简单和高效，在实际中应用非常广泛。<br> 比如在实际工作中，我们可能会遇到如下问题：</p> <p>预测一个用户是否点击特定的商品<br> 判断用户的性别<br> 预测用户是否会购买给定的品类<br> 判断一条评论是正面的还是负面的</p> <p>这些都可以看做是分类问题，更准确地，都可以看做是二分类问题。要解决这些问题，通常会用到一些已有的分类算法，比如逻辑回归，或者支持向量机。它们都属于有监督的学习，因此在使用这些算法之前，必须要先收集一批标注好的数据作为训练集。有些标注可以从log中拿到（用户的点击，购买），有些可以从用户填写的信息中获得（性别），也有一些可能需要人工标注（评论情感极性）。</p> </li><li>说一下Adaboost，权值更新公式。当弱分类器是Gm时，每个样本的的权重是w1，w2...，请写出最终的决策公式。 <p>给定一个训练数据集T={(x1,y1),&nbsp;(x2,y2)…(xN,yN)}..</p> </li><li>经常在网上搜索东西的朋友知道，当你不小心输入一个不存在的单词时，搜索引擎会提示你是不是要输入某一个正确的单词，比如当你在Google中输入“Julw”时，系统会猜测你的意图：是不是要搜索“July” <p>用户输入一个单词时，可能拼写正确，也可能拼写错误。如果把拼写正确的情况记做c（代表correct），拼写错误的情况记做w（代表wrong），那么"拼写检查"要做的事情就是：在发生w的情况下，试图推断出c。换言之：已知w，然后在若干个备选方案中，找出可能性最大的那个c..</p> </li><li>为什么朴素贝叶斯如此“朴素”？ <p>因为它假定所有的特征在数据集中的作用是同样重要和独立的。正如我们所知，这个假设在现实世界中是很不真实的，因此，说朴素贝叶斯真的很“朴素”。</p> <p>朴素贝叶斯模型(Naive Bayesian Model)的朴素(Naive)的含义是"很简单很天真"地假设样本特征彼此独立. 这个假设现实中基本上不存在, 但特征相关性很小的实际情况还是很多的, 所以这个模型仍然能够工作得很好。</p> </li><li>请大致对比下plsa和LDA的区别<br> 两者的区别代表了概率学派和贝叶斯学派的区别，即后者加上了先验概率分布..</li><li>请详细说说EM算法 <p>到底什么是EM算法呢？Wikipedia给的解释是：</p> <p>最大期望算法（Expectation-maximization algorithm，又译为期望最大化算法），是在概率模型中寻找参数最大似然估计或者最大后验估计的算法，其中概率模型依赖于无法观测的隐性变量。</p> </li><li>KNN中的K如何选取的？ <p>关于什么是KNN，可以查看此文：《从K近邻算法、距离度量谈到KD树、SIFT+BBF算法》（链接：http://blog.csdn.net/v_july_v/article/details/8203674）。KNN中的K值选取对K近邻算法的结果会产生重大影响。如李航博士的一书「统计学习方法」上所说：</p> <p>如果选择较小的K值，就相当于用较小的领域中的训练实例进行预测，“学习”近似误差会减小，只有与输入实例较近或相似的训练实例才会对预测结果起作用，与此同时带来的问题是“学习”的估计误差会增大，换句话说，K值的减小就意味着整体模型变得复杂，容易发生过拟合；<br> 如果选择较大的K值，就相当于用较大领域中的训练实例进行预测，其优点是可以减少学习的估计误差，但缺点是学习的近似误差会增大。这时候，与输入实例较远（不相似的）训练实例也会对预测器作用，使预测发生错误，且K值的增大就意味着整体的模型变得简单。<br> K=N，则完全不足取，因为此时无论输入实例是什么，都只是简单的预测它属于在训练实例中最多的累，模型过于简单，忽略了训练实例中大量有用信息。<br> &nbsp; &nbsp; 在实际应用中，K值一般取一个比较小的数值，例如采用交叉验证法（简单来说，就是一部分样本做训练集，一部分做测试集）来选择最优的K值。</p> </li><li>防止过拟合的方法 <p>过拟合的原因是算法的学习能力过强；一些假设条件（如样本独立同分布）可能是不成立的；训练样本过少不能对整个空间进行分布估计。&nbsp;</p> <p>处理方法：<br> 1 早停止：如在训练中多次迭代后发现模型性能没有显著提高就停止训练<br> 2 数据集扩增：原有数据增加、原有数据加随机噪声、重采样<br> 3 正则化，正则化可以限制模型的复杂度<br> 4 交叉验证<br> 5 特征选择/特征降维<br> 6 创建一个验证集是最基本的防止过拟合的方法。我们最终训练得到的模型目标是要在验证集上面有好的表现，而不训练集</p> </li><li>机器学习中，为何要经常对数据做归一化 <p>机器学习模型被互联网行业广泛应用，如排序（参见：排序学习实践http://www.cnblogs.com/LBSer/p/4439542.html）、推荐、反作弊、定位（参见：基于朴素贝叶斯的定位算法http://www.cnblogs.com/LBSer/p/4020370.html）等。</p> <p>一般做机器学习应用的时候大部分时间是花费在特征处理上，其中很关键的一步就是对特征数据进行归一化。</p> <p>为什么要归一化呢？很多同学并未搞清楚，维基百科给出的解释：1）归一化后加快了梯度下降求最优解的速度；2）归一化有可能提高精度。</p> </li><li>什么最小二乘法？ <p>我们口头中经常说：一般来说，平均来说。如平均来说，不吸烟的健康优于吸烟者，之所以要加“平均”二字，是因为凡事皆有例外，总存在某个特别的人他吸烟但由于经常锻炼所以他的健康状况可能会优于他身边不吸烟的朋友。而最小二乘法的一个最简单的例子便是算术平均。</p> <p>&nbsp; &nbsp; 最小二乘法（又称最小平方法）是一种数学优化技术。它通过最小化误差的平方和寻找数据的最佳函数匹配。利用最小二乘法可以简便地求得未知的数据，并使得这些求得的数据与实际数据之间误差的平方和为最小。</p> </li><li>梯度下降法找到的一定是下降最快的方向么？ <p>梯度下降法并不一定是全局下降最快的方向，它只是目标函数在当前的点的切平面（当然高维问题不能叫平面）上下降最快的方向。在practical implementation中，牛顿方向（考虑海森矩阵）才一般被认为是下降最快的方向，可以达到superlinear的收敛速度。梯度下降类的算法的收敛速度一般是linear甚至sublinear的（在某些带复杂约束的问题）。by林小溪（https://www.zhihu.com/question/30672734/answer/139689869）。</p> </li><li>简单说说贝叶斯定理的<br> 在引出贝叶斯定理之前，先学习几个定义：<br> 条件概率（又称后验概率）就是事件A在另外一个事件B已经发生条件下的发生概率。条件概率表示为P(A|B)，读作“在B条件下A的概率”。<br> &nbsp;&nbsp; &nbsp;比如，在同一个样本空间Ω中的事件或者子集A与B，如果随机从Ω中选出的一个元素属于B，那么这个随机选择的元素还属于A的概率就定义为在B的前提下A的条件概率，所以：P(A|B) = |A∩B|/|B|，接着分子、分母都除以|Ω|得到..</li><li>怎么理解决策树、xgboost能处理缺失值？而有的模型(svm)对缺失值比较敏感。 <p>本题解析来源：https://www.zhihu.com/question/58230411</p> <p>首先从两个角度解释你的困惑：<br> 工具包自动处理数据缺失不代表具体的算法可以处理缺失项<br> 对于有缺失的数据：以决策树为原型的模型优于依赖距离度量的模型</p> <p>回答中也会介绍树模型，如随机森林(Random Forest)和xgboost如何处理缺失值。文章最后总结了在有缺失值时选择模型的小建议。</p> </li><li>请举例说明什么是标准化、归一化 <p>一、标准化（standardization）<br> 简单来说，标准化是依照特征矩阵的列处理数据，其通过求z-score的方法，将样本的特征值转换到同一量纲下。<br> 公式一般为：(X-mean)/std，其中mean是平均值，std是方差。</p> <p>从公式我们可以看出，标准化操作（standardization）是将数据按其属性（按列）减去平均值，然后再除以方差。</p> <p>这个过程从几何上理解就是，先将坐标轴零轴平移到均值这条线上，然后再进行一个缩放，涉及到的就是平移和缩放两个动作。这样处理以后的结果就是，对于每个属性（每列）来说，所有数据都聚集在0附近，方差为1。计算时对每个属性/每列分别进行。</p> </li><li>随机森林如何处理缺失值？ <p>@Yieshah：众所周知，机器学习中处理缺失值的方法有很多，然而，由题目“随机森林如何处理缺失值”可知，问题关键在于随机森林如何处理，所以先简要介绍下随机森林吧。</p> <p>随机森林是由很多个决策树组成的，首先要建立Bootstrap数据集，即从原始的数据中有放回地随机选取一些，作为新的数据集，新数据集中会存在重复的数据，然后对每个数据集构造一个决策树，但是不是直接用所有的特征来建造决策树，而是对于每一步，都从中随机的选择一些特征，来构造决策树，这样我们就构建了多个决策树，组成随机森林，把数据输入各个决策树中，看一看每个决策树的判断结果，统计一下所有决策树的预测结果，Bagging整合结果，得到最终输出。</p> <p>那么，随机森林中如何处理缺失值呢？根据随机森林创建和训练的特点，随机森林对缺失值的处理还是比较特殊的。</p> </li><li>随机森林如何评估特征重要性？<br> 衡量变量重要性的方法有两种，Decrease GINI 和 Decrease Accuracy：</li><li>请说说Kmeans的优化？ <p>解析一<br> k-means：在大数据的条件下，会耗费大量的时间和内存。&nbsp;</p> <p>&nbsp; 优化k-means的建议：&nbsp;<br> &nbsp; 1、减少聚类的数目K。因为，每个样本都要跟类中心计算距离。&nbsp;<br> &nbsp; 2、减少样本的特征维度。比如说，通过PCA等进行降维。&nbsp;<br> &nbsp; 3、考察其他的聚类算法，通过选取toy数据，去测试不同聚类算法的性能。&nbsp;<br> &nbsp; 4、hadoop集群，K-means算法是很容易进行并行计算的。&nbsp;</p> </li><li>KMeans算法k值及初始类簇中心点的选取 <p>KMeans算法是最常用的聚类算法，主要思想是:在给定K值和K个初始类簇中心点的情况下，把每个点(亦即数据记录)分到离其最近的类簇中心点所代表的类簇中，所有点分配完毕之后，根据一个类簇内的所有点重新计算该类簇的中心点(取平均值)，然后再迭代的进行分配点和更新类簇中心点的步骤，直至类簇中心点的变化很小，或者达到指定的迭代次数。</p> <p>&nbsp; KMeans算法本身思想比较简单，但是合理的确定K值和K个初始类簇中心点对于聚类效果的好坏有很大的影响。</p> </li><li>解释对偶的概念<br> 一个优化问题可以从两个角度进行考察，一个是primal 问题，一个是dual 问题，就是对偶问题，一般情况下对偶问题给出主问题最优值的下界，在强对偶性成立的情况下由对偶问题可以得到主问题的最优下界，对偶问题是凸优化问题，可以进行较好的求解，SVM中就是将primal问题转换为dual问题进行求解，从而进一步引入核函数的思想。</li><li>如何进行特征选择？<br> 特征选择是一个重要的数据预处理过程，主要有两个原因：一是减少特征数量、降维，使模型泛化能力更强，减少过拟合;二是增强对特征和特征值之间的理解<br> 常见的特征选择方式：<br> 1. 去除方差较小的特征<br> 2. 正则化。L1正则化能够生成稀疏的模型。L2正则化的表现更加稳定，由于有用的特征往往对应系数非零。<br> 3. 随机森林，对于分类问题，通常采用基尼不纯度或者信息增益，对于回归问题，通常采用的是方差或者最小二乘拟合。一般不需要feature engineering、调参等繁琐的步骤。它的两个主要问题，1是重要的特征有可能得分很低（关联特征问题），2是这种方法对特征变量类别多的特征越有利（偏向问题）。<br> 4. 稳定性选择。是一种基于二次抽样和选择算法相结合较新的方法，选择算法可以是回归、SVM或其他类似的方法。它的主要思想是在不同的数据子集和特征子集上运行特征选择算法，不断的重复，最终汇总特征选择结果，比如可以统计某个特征被认为是重要特征的频率（被选为重要特征的次数除以它所在的子集被测试的次数）。理想情况下，重要特征的得分会接近100%。稍微弱一点的特征得分会是非0的数，而最无用的特征得分将会接近于0。</li><li>衡量分类器的好坏？<br> 这里首先要知道TP、FN（真的判成假的）、FP（假的判成真）、TN四种（可以画一个表格）。&nbsp;</li><li>机器学习和统计里面的auc的物理意义是啥？ <p>auc是评价模型好坏的常见指标之一，本题解析来自：https://www.zhihu.com/question/39840928</p> <p>分三部分，第一部分是对AUC的基本介绍，包括AUC的定义，解释，以及算法和代码，第二部分用逻辑回归作为例子来说明如何通过直接优化AUC来训练，第三部分，内容完全由@李大猫原创——如何根据auc值来计算真正的类别，换句话说，就是对auc的反向工程。</p> </li><li>数据预处理<br> 1. 缺失值，填充缺失值fillna：<br> i. 离散：None,<br> ii. 连续：均值。<br> iii. 缺失值太多，则直接去除该列<br> 2. 连续值：离散化。有的模型（如决策树）需要离散值<br> 3. 对定量特征二值化。核心在于设定一个阈值，大于阈值的赋值为1，小于等于阈值的赋值为0。如图像操作<br> 4. 皮尔逊相关系数，去除高度相关的列</li><li>观察增益gain, alpha和gamma越大，增益越小？<br> xgboost寻找分割点的标准是最大化gain. 考虑传统的枚举每个特征的所有可能分割点的贪心法效率太低，xgboost实现了一种近似的算法。大致的思想是根据百分位法列举几个可能成为分割点的候选者，然后从候选者中计算Gain按最大值找出最佳的分割点。它的计算公式分为四项, 可以由正则化项参数调整(lamda为叶子权重平方和的系数, gama为叶子数量)..</li><li>什麽造成梯度消失问题?<br> Yes you should understand backdrop－Andrej Karpathy<br> How does the ReLu solve the vanishing gradient problem?<br> 神经网络的训练中，通过改变神经元的权重，使网络的输出值尽可能逼近标签以降低误差值，训练普遍使用BP算法，核心思想是，计算出输出与标签间的损失函数值，然后计算其相对于每个神经元的梯度，进行权值的迭代。<br> 梯度消失会造成权值更新缓慢，模型训练难度增加。造成梯度消失的一个原因是，许多激活函数将输出值挤压在很小的区间内，在激活函数两端较大范围的定义域内梯度为0，造成学习停止。</li><li>到底什么是特征工程？<br> 首先，大多数机器学习从业者主要在公司做什么呢？不是做数学推导，也不是发明多高大上的算法，而是做特征工程，如下图所示（图来自：http://www.julyedu.com/video/play/18）</li><li>你知道有哪些数据处理和特征工程的处理？</li><li>准备机器学习面试应该了解哪些理论知识？<img alt="" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9qdWx5ZWR1LWltZy1wdWJsaWMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL1B1YmxpYy9JbWFnZS9RdWVzdGlvbi8xNTEyOTgxMDcwXzYxMC5wbmc?x-oss-process=image/format,png"></li><li>数据不平衡问题 <p>这主要是由于数据分布不平衡造成的。解决方法如下：</p> <p>采样，对小样本加噪声采样，对大样本进行下采样<br> 数据生成，利用已知样本生成新的样本<br> 进行特殊的加权，如在Adaboost中或者SVM中<br> 采用对不平衡数据集不敏感的算法<br> 改变评价标准：用AUC/ROC来进行评价<br> 采用Bagging/Boosting/ensemble等方法<br> 在设计模型的时候考虑数据的先验分布</p> </li><li>特征比数据量还大时，选择什么样的分类器？<br> 线性分类器，因为维度高的时候，数据一般在维度空间里面会比较稀疏，很有可能线性可分。</li><li>常见的分类算法有哪些？他们各自的优缺点是什么？ <p>贝叶斯分类法<br> 优点：<br> 1）所需估计的参数少，对于缺失数据不敏感。<br> 2）有着坚实的数学基础，以及稳定的分类效率。&nbsp;&nbsp; &nbsp;</p> <p>缺点：<br> 1）假设属性之间相互独立，这往往并不成立。（喜欢吃番茄、鸡蛋，却不喜欢吃番茄炒蛋）。<br> 2）需要知道先验概率。<br> 3）分类决策存在错误率。</p> </li><li>常见的监督学习算法有哪些？<br> 感知机、svm、人工神经网络、决策树、逻辑回归</li><li>说说常见的优化算法及其优缺点？<br> 1）随机梯度下降<br> 优点：容易陷入局部最优解<br> 缺点：收敛速度较快<br> 2）批量梯度下降<br> 优点：可以一定程度上解决局部最优解的问题</li><li>特征向量的归一化方法有哪些？<br> 线性函数转换，表达式如下：<br> y=(x-MinValue)/(MaxValue-MinValue)<br> 对数函数转换，表达式如下：<br> y=log10 (x)<br> 反余切函数转换 ，表达式如下：<br> y=arctan(x)*2/PI<br> 减去均值，除以标准差：<br> y=(x-means)/ Standard Deviation</li><li>RF与GBDT之间的区别与联系？ <p>1）相同点：都是由多棵树组成，最终的结果都是由多棵树一起决定。</p> <p>2）不同点：<br> a 组成随机森林的树可以分类树也可以是回归树，而GBDT只由回归树组成；<br> b 组成随机森林的树可以并行生成，而GBDT是串行生成<br> c 随机森林的结果是多数表决表决的，而GBDT则是多棵树累加之和<br> d 随机森林对异常值不敏感，而GBDT对异常值比较敏感<br> e 随机森林是减少模型的方差，而GBDT是减少模型的偏差</p> <p>f GBDT的会累加所有树的结果，而这种累加是无法通过分类完成的，因此GBDT的树都是CART回归树，而不是分类树（尽管GBDT调整后也可以用于分类但不代表GBDT的树为分类树）</p> </li><li>试证明样本空间中任意点 x 到超平面 (w,b) 的距离公式</li><li>请比较下EM算法、HMM、CRF<br> 这三个放在一起不是很恰当，但是有互相有关联，所以就放在这里一起说了。注意重点关注算法的思想。&nbsp;<br> （1）EM算法&nbsp;<br> 　　EM算法是用于含有隐变量模型的极大似然估计或者极大后验估计，有两步组成：E步，求期望（expectation）；M步，求极大（maxmization）。本质上EM算法还是一个迭代算法，通过不断用上一代参数对隐变量的估计来对当前变量进行计算，直到收敛。&nbsp;<br> 　　注意：EM算法是对初值敏感的，而且EM是不断求解下界的极大化逼近求解对数似然函数的极大化的算法，也就是说EM算法不能保证找到全局最优值。对于EM的导出方法也应该掌握。&nbsp;</li><li>带核的SVM为什么能分类非线性问题？ <pre><code class="language-html hljs language-xml">核函数的本质是两个函数的內积，通过核函数将其隐射到高维空间，在高维空间非线性问题转化为线性问题, SVM得到超平面是高维空间的线性分类平面</code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre> </li><li>请说说常用核函数及核函数的条件 <pre><code class="language-html hljs language-xml">我们通常说的核函数指的是正定和函数，其充要条件是对于任意的x属于X，要求K对应的Gram矩阵要是半正定矩阵。RBF核径向基，这类函数取值依赖于特定点间的距离，所以拉普拉斯核其实也是径向基核。SVM关键是选取核函数的类型，常用核函数主要有线性内核，多项式内核，径向基内核（RBF），sigmoid核。</code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre> </li><li>请具体说说Boosting和Bagging的区别 <pre><code class="language-html hljs language-xml"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">（1） Bagging之随机森林 </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　随机森林改变了决策树容易过拟合的问题，这主要是由两个操作所优化的：</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　1）Boostrap从袋内有放回的抽取样本值</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　2）每次随机抽取一定数量的特征（通常为sqr(n)）。 </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　分类问题：采用Bagging投票的方式选择类别频次最高的 </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　回归问题：直接取每颗树结果的平均值。</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre> </li><li>逻辑回归相关问题 <pre><code class="language-html hljs language-xml"><ol class="hljs-ln" style="width:1883px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">（1）公式推导一定要会</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">（2）逻辑回归的基本概念 </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　这个最好从广义线性模型的角度分析，逻辑回归是假设y服从Bernoulli分布。</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">（3）L1-norm和L2-norm </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　其实稀疏的根本还是在于L0-norm也就是直接统计参数不为0的个数作为规则项，但实际上却不好执行于是引入了L1-norm；而L1norm本质上是假设参数先验是服从Laplace分布的，而L2-norm是假设参数先验为Gaussian分布，我们在网上看到的通常用图像来解答这个问题的原理就在这。 </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　但是L1-norm的求解比较困难，可以用坐标轴下降法或是最小角回归法求解。</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">（4）LR和SVM对比 </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　首先，LR和SVM最大的区别在于损失函数的选择，LR的损失函数为Log损失（或者说是逻辑损失都可以）、而SVM的损失函数为hinge loss。 </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　其次，两者都是线性模型。 </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　最后，SVM只考虑支持向量（也就是和分类相关的少数点） </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">（5）LR和随机森林区别 </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　随机森林等树算法都是非线性的，而LR是线性的。LR更侧重全局优化，而树模型主要是局部的优化。 </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">（6）</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre> </li><li>什么是共线性, 跟过拟合有什么关联? <pre><code class="language-html hljs language-xml"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">共线性：多变量线性回归中，变量之间由于存在高度相关关系而使回归估计不准确。</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">共线性会造成冗余，导致过拟合。</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">解决方法：排除变量的相关性／加入权重正则。</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre> </li><li>机器学习中，有哪些特征选择的工程方法？ <pre><code class="language-html hljs language-xml"><ol class="hljs-ln" style="width:1881px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">目录</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">1 特征工程是什么？</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">2 数据预处理</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　2.1 无量纲化</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　　　2.1.1 标准化</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　　　2.1.2 区间缩放法</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　　　2.1.3 标准化与归一化的区别</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　2.2 对定量特征二值化</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　2.3 对定性特征哑编码</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　2.4 缺失值计算</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　2.5 数据变换</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　2.6 回顾</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">3 特征选择</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　3.1 Filter</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　　　3.1.1 方差选择法</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　　　3.1.2 相关系数法</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　　　3.1.3 卡方检验</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　　　3.1.4 互信息法</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　3.2 Wrapper</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　　　3.2.1 递归特征消除法</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　3.3 Embedded</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="22"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　　　3.3.1 基于惩罚项的特征选择法</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="23"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　　　3.3.2 基于树模型的特征选择法</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="24"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　3.4 回顾</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="25"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">4 降维</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="26"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　4.1 主成分分析法（PCA）</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="27"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　4.2 线性判别分析法（LDA）</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="28"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　4.3 回顾</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="29"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">5 总结</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="30"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">6 参考资料</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="31"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="32"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">1 特征工程是什么？</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="33"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">　　有这么一句话在业界广泛流传：数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已。那特征工程到底是什么呢？顾名思义，其本质是一项工程活动，目的是最大限度地从原始数据中提取特征以供算法和模型使用。通过总结和归纳，人们认为特征工程包括以下方面：..</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre> </li><li>用贝叶斯机率说明Dropout的原理 <pre><code class="language-html hljs language-xml"><ol class="hljs-ln" style="width:1476px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">回想一下使用Bagging学习,我们定义 k 个不同的模型,从训练集有替换采样 构造 k 个不同的数据集,然后在训练集上训练模型 i。</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">Dropout的目标是在指数 级数量的神经网络上近似这个过程。Dropout训练与Bagging训练不太一样。在Bagging的情况下,所有模型是独立 的。</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">在Dropout的情况下,模型是共享参数的,其中每个模型继承的父神经网络参 数的不同子集。参数共享使得在有限可用的内存下代表指数数量的模型变得可能。 在Bagging的情况下,每一个模型在其相应训练集上训练到收敛。</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">在Dropout的情况下,通常大部分模型都没有显式地被训练,通常该模型很大,以致到宇宙毁灭都不 能采样所有可能的子网络。取而代之的是,可能的子网络的一小部分训练单个步骤,参数共享导致剩余的子网络能有好的参数设定。</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre> </li><li>对于维度极低的特征，选择线性还是非线性分类器？ <pre><code class="language-html hljs language-xml"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">非线性分类器，低维空间可能很多特征都跑到一起了，导致线性不可分。</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">1. 如果Feature的数量很大，跟样本数量差不多，这时候选用LR或者是Linear Kernel的SVM</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">2. 如果Feature的数量比较小，样本数量一般，不算大也不算小，选用SVM+Gaussian Kernel</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">3. 如果Feature的数量比较小，而样本数量很多，需要手工添加一些feature变成第一种情况。</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre> </li><li>请问怎么处理特征向量的缺失值 <pre><code class="language-html hljs language-xml"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">一方面，缺失值较多.直接将该特征舍弃掉，否则可能反倒会带入较大的noise，对结果造成不良影响。</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">另一方面缺失值较少,其余的特征缺失值都在10%以内，我们可以采取很多的方式来处理:</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">1) 把NaN直接作为一个特征，假设用0表示；</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">2) 用均值填充；</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">3) 用随机森林等算法预测填充。</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre> </li><li>SVM、LR、决策树的对比 <pre><code class="language-html hljs language-xml"><ol class="hljs-ln" style="width:912px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">模型复杂度：SVM支持核函数，可处理线性非线性问题;LR模型简单，训练速度快，适合处理线性问题;决策树容易过拟合，需要进行剪枝</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">损失函数：SVM hinge loss; LR L2 logistical loss（对数似然损失）; adaboost 指数损失</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">数据敏感度：SVM添加容忍度对outlier不敏感，只关心支持向量，且需要先做归一化; LR对异常点敏感</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">数据量：数据量大就用LR，数据量小且特征少就用SVM非线性核</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre> </li><li>简述KNN最近邻分类算法的过程 <pre><code class="language-html hljs language-xml"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">1. 计算测试样本和训练样本中每个样本点的距离（常见的距离度量有欧式距离，马氏距离等）；</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">2. 对上面所有的距离值进行排序；</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">3. 选前 k 个最小距离的样本；</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">4. 根据这 k 个样本的标签进行投票，得到最后的分类类别；</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre> </li><li>常用的聚类划分方式有哪些？列举代表算法 <pre><code class="language-html hljs language-xml"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">1. 基于划分的聚类:K-means，k-medoids，CLARANS。</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">2. 基于层次的聚类：AGNES（自底向上），DIANA（自上向下），BIRCH(CF-Tree)，。</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">3. 基于密度的聚类：DBSACN，OPTICS，CURE。</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">4. 基于网格的方法：STING，WaveCluster。</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">5. 基于模型的聚类：EM,SOM，COBWEB。</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre> </li><li>什么是偏差与方差？ <pre><code class="language-html hljs language-xml">泛化误差可以分解成偏差的平方加上方差加上噪声。偏差度量了学习算法的期望预测和真实结果的偏离程度，刻画了学习算法本身的拟合能力，方差度量了同样大小的训练集的变动所导致的学习性能的变化，刻画了数据扰动所造成的影响，噪声表达了当前任务上任何学习算法所能达到的期望泛化误差下界，刻画了问题本身的难度。偏差和方差一般称为bias和variance，一般训练程度越强，偏差越小，方差越大，泛化误差一般在中间有一个最小值，如果偏差较大，方差较小，此时一般称为欠拟合，而偏差较小，方差较大称为过拟合。</code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre> </li><li>解决bias和Variance问题的方法是什么？ <pre><code class="language-html hljs language-xml"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">High bias解决方案:Boosting、复杂模型（非线性模型、增加神经网络中的层）、更多特征</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">High Variance解决方案：bagging、简化模型、降维</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre> </li><li>采用 EM 算法求解的模型有哪些，为什么不用牛顿法或梯度下降法？ <pre><code class="language-html hljs language-xml">用EM算法求解的模型一般有GMM或者协同过滤，k-means其实也属于EM。EM算法一定会收敛，但是可能收敛到局部最优。由于求和的项数将随着隐变量的数目指数上升，会给梯度计算带来麻烦。</code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre> </li><li>xgboost怎么给特征评分？ <pre><code class="language-html hljs language-xml"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">我们知道，在训练的过程中，cart树通过Gini指数选择分离点的特征，一个特征被选中的次数越多，那么该特征评分越高。</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">但xgboost呢？对于一个叶子节点如何进行分裂，xgboost作者在其原始论文中给出了两种分裂节点的方法</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre> </li><li>什么是OOB？随机森林中OOB是如何计算的，它有什么优缺点？</li><li>推导朴素贝叶斯分类 P(c|d)，文档 d（由若干 word 组成），求该文档属于类别 c 的概率， 并说明公式中哪些概率可以利用训练集计算得到</li><li>请写出你了解的机器学习特征工程操作，以及它的意义</li><li>请写出你对VC维的理解和认识</li><li>kmeans聚类中，如何确定k的大小</li><li>请用Python实现下线性回归，并思考下更高效的实现方式</li><li>怎么理解“机器学习的各种模型与他们各自的损失函数一一对应？”</li><li>给你一个有1000列和1百万行的训练数据集。这个数据集是基于分类问题的。经理要求你来降低该数据集的维度以减少模型计算时间。你的机器内存有限。你会怎么做？（你可以自由做各种实际操作假设）</li><li>问2：在PCA中有必要做旋转变换吗？如果有必要，为什么？如果你没有旋转变换那些成分，会发生什么情况？</li><li>给你一个数据集，这个数据集有缺失值，且这些缺失值分布在离中值有1个标准偏差的范围内。百分之多少的数据不会受到影响？为什么？</li><li>给你一个癌症检测的数据集。你已经建好了分类模型，取得了96％的精度。为什么你还是不满意你的模型性能？你可以做些什么呢？</li><li>解释朴素贝叶斯算法里面的先验概率、似然估计和边际似然估计？</li><li>你正在一个时间序列数据集上工作。经理要求你建立一个高精度的模型。你开始用决策树算法，因为你知道它在所有类型数据上的表现都不错。后来，你尝试了时间序列回归模型，并得到了比决策树模型更高的精度。这种情况会发生吗？为什么</li><li>给你分配了一个新的项目，是关于帮助食品配送公司节省更多的钱。问题是，公司的送餐队伍没办法准时送餐。结果就是他们的客户很不高兴。最后为了使客户高兴，他们只好以免餐费了事。哪个机器学习算法能拯救他们？</li><li>你意识到你的模型受到低偏差和高方差问题的困扰。应该使用哪种算法来解决问题呢？为什么？</li><li>给你一个数据集。该数据集包含很多变量，你知道其中一些是高度相关的。经理要求你用PCA。你会先去掉相关的变量吗？为什么？</li><li>花了几个小时后，现在你急于建一个高精度的模型。结果，你建了5 个GBM （Gradient Boosted Models），想着boosting算法会显示魔力。不幸的是，没有一个模型比基准模型表现得更好。最后，你决定将这些模型结合到一起。尽管众所周知，结合模型通常精度高，但你就很不幸运。你到底错在哪里？</li><li>KNN和KMEANS聚类（kmeans clustering）有什么不同？</li><li>真阳性率和召回有什么关系？写出方程式。</li><li>在分析了你的模型后，经理告诉你，你的模型有多重共线性。你会如何验证他说的是真的？在不丢失任何信息的情况下，你还能建立一个更好的模型吗？</li><li>什么时候Ridge回归优于Lasso回归？</li><li>如何在一个数据集上选择重要的变量？给出解释。</li><li>Gradient boosting算法（GBM）和随机森林都是基于树的算法，它们有什么区别？</li><li>运行二元分类树算法很容易，但是你知道一个树是如何做分割的吗，即树如何决定把哪些变量分到哪个根节点和后续节点上？</li><li>你有一个数据集，变量个数p大于观察值个数n。为什么用OLS是一个不好的选择？用什么技术最好？为什么？</li><li>什么是凸包？（提示：想一想SVM）其他方法还包括子集回归、前向逐步回归。</li><li>我们知道，独热编码（OneHotEncoder）会增加数据集的维度。但是标签编码（LabelEncoder）不会。为什么？</li><li>你会在时间序列数据集上使用什么交叉验证技术？是用k倍或LOOCV？</li><li>给你一个缺失值多于30%的数据集？比方说，在50个变量中，有8个变量的缺失值都多于30%。你对此如何处理？</li><li>“买了这个的客户，也买了......”亚马逊的建议是哪种算法的结果？</li><li>你怎么理解第一类和第二类错误？</li><li>当你在解决一个分类问题时，出于验证的目的，你已经将训练集随机抽样地分成训练集和验证集。你对你的模型能在未看见的数据上有好的表现非常有信心，因为你的验证精度高。但是，在得到很差的精度后，你大失所望。什么地方出了错？</li><li>请简单阐述下决策树、回归、SVM、神经网络等算法各自的优缺点？正则化算法（Regularization Algorithms）集成算法（Ensemble Algorithms）决策树算法（Decision Tree Algorithm）回归（Regression）人工神经网络（Artificial Neural Network）深度学习（Deep Learning）支持向量机（Support Vector Machine）降维算法（Dimensionality Reduction Algorithms）聚类算法（Clustering Algorithms）基于实例的算法（Instance-based Algorithms）贝叶斯算法（Bayesian Algorithms）关联规则学习算法（Association Rule Learning Algorithms）图模型（Graphical Models）</li><li>在应用机器学习算法之前纠正和清理数据的步骤是什么？</li><li>什么是K-means聚类算法？</li><li>如何理解模型的过拟合与欠拟合，以及如何解决？</li><li>请详细说说文字特征提取</li><li>请详细说说图像特征提取</li><li>了解xgboost么，请详细说说它的原理</li><li>请详细说说梯度提升树(GBDT)的原理</li><li>请说说Adaboost 算法的原理与推导</li><li>机器学习中的L0、L1与L2范数到底是什么意思？</li><li>请详细说说决策树的构造原理</li><li>怎么确定LDA的topic个数？</li><li>sklearn随机森林的特征重要度是不是偏好数值型变量呢？我在做kaggle的Titanic问题时使用随机森林和xgboost发现两个数值型的变量重要度非常高，远远高过性别这种在数据分析时候认为很重要的特征看sklearn文档说特征重要度是按照特征对不纯度减少的贡献来排的，刚才在网上找到了一篇论文大概是说这种特征重要度的衡量方式会偏好那些类别多的变量（feature selection based on impurity reduction is biased towards preferring variables with more categories）。sklearn的文档说sklearn的决策树都是cart树，cart树在对待数值型特征的时候也可以理解成一个类别数等于样本数的类别型特征吧。那么是因为这个原因导致随机森林偏好数值型特征吗？</li><li>连续特征，既可以离散化，也可以做幅度缩放，那这两种处理方式分别适用于什么场景呢？</li><li>从几何直观的角度解释下为什么拉格朗日乘子法能取到最优值？</li><li>A/B测试的数学原理与深入理解</li><li><s>如何更科学的做机器学习100天入门计划</s></li><li>如何通俗理解主成成分分析PCA</li><li>如何通俗理解LightGBM</li><li>线性回归要求因变量服从正态分布？</li><li>什么是K近邻算法和KD树？</li><li>如何通俗理解贝叶斯方法和贝叶斯网络？</li><li>最大熵模型中的数学推导</li><li>关于xgboost使用泰勒展开式的优点？泰勒展开取得函数做自变量的二阶导数形式, 可以在不选定损失函数具体形式的情况下, 仅仅依靠输入数据的值就可以进行叶子分裂优化计算, 本质上也就把损失函数的选取和模型算法优化/参数选择分开了.&nbsp;请问为什么在 可以在不选定损失函数具体形式的情况下, 仅仅依靠输入数据的值就可以进行叶子分裂优化计算？</li><li>你有自己用过别的模型然后调参之类的吗？能说一下基本的调参流程吗？XGBoost知道吗，以XGBoost为例子说一下调参流程吧。</li><li>XGBoost和GBDT的区别有哪些？</li><li>XGB特征重要性程度是怎么判断的？</li><li>xgb的预排序算法是怎么做的呢？</li><li>RF和xgboost哪个对异常点更敏感</li><li>xgb何时停止分裂？</li><li>对比一下XGB和lightGBM在节点分裂时候的区别</li><li>简要说一下Lightgbm相对于xgboost的优缺点</li><li>xgboost对特征缺失敏感吗，对缺失值做了什么操作，存在什么问题</li><li>xgb和lgb在特征、数据并行上存在什么差异？</li><li>为什么xgboost不用后剪枝？</li></ol>
<p></p> 
<p></p> 

</div>